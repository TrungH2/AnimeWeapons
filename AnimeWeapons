local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer

-- ===================================================================
-- I. CONFIGURATION
-- ===================================================================

local Config = {
    StealthMode = true,
    AttackRange = 50,
    CollectRange = 20,
    EnemyRefreshRate = 0.5,
    FarmInterval = 0.1,
    TeleportCooldown = 2,
    MaxCollectPerFrame = 10,
    RemotePatterns = {
        Reply = {"Reply"},
        Attack = {"RemoteEvent", "Remote"}
    },
    Zones = {
        ["Shinobi Village"] = "Naruto",
        ["Namek Planet"] = "DragonBall",
        ["Desert Land"] = "OnePiece",
        ["Demon Land"] = "DemonSlayer",
        ["Dungeon Easy"] = "Dungeon:1",
        ["Zone 1"] = "Zone 1",
        ["Zone 2"] = "Zone 2",
        ["Zone 3"] = "Zone 3",
        ["Zone 4"] = "Zone 4",
    },
    StatTypes = {"Damage", "Mastery", "Luck", "Yen"},
    GachaTypes = {"Biju", "Race", "Sayajin", "Haki", "Fruits"},
}

local sortedZoneKeys = {}
for key, _ in pairs(Config.Zones) do table.insert(sortedZoneKeys, key) end
table.sort(sortedZoneKeys)

-- ===================================================================
-- II. STATE VARIABLES & CONFIG
-- ===================================================================

local stealthMode = Config.StealthMode
local safeConnections = {}
local activeLoops = {}
local selectedEnemyNames = {}
local selectedGachaType = Config.GachaTypes[1] or "Biju"
local selectedStat = Config.StatTypes[1] or "Damage"
local selectedZone = sortedZoneKeys[1] or "Zone 1"
local lastTeleportTime = 0
local HimonoHub, HimonoMini
local TitleBar, MainContainer, MiniButton
local antiAFKConnection = nil
local configFile = "HimonoHubModernConfig.txt"

-- Bi·∫øn theo d√µi tr·∫°ng th√°i cho Save/Load
local selectedFarmEnabled = false
local autoAttackEnabled = false
local farmRandomEnabled = false
local autoCollectEnabled = false
local stealthModeEnabled = Config.StealthMode
local antiAFKEnabled = true
local autoOpenEggEnabled = false

-- Bi·∫øn Dungeon
local isDungeonActive = false
local autoDungeonFarmEnabled = false
local isPlayerInDungeon = false
local lastZone = selectedZone

-- Bi·∫øn l∆∞u tr·∫°ng th√°i Farm tr∆∞·ªõc khi v√†o Dungeon
local wasAutoAttackEnabled = false
local wasFarmSelectedEnabled = false
local wasFarmRandomEnabled = false
local wasAutoCollectEnabled = false

-- ===================================================================
-- III. CORE UTILITIES (ANTI-LEAK & STABILITY)
-- ===================================================================

local function GetReplyRemote()
    for _, name in pairs({"Reply", "ReplicatedStorage", "MainRemote"}) do
        local remote = ReplicatedStorage:FindFirstChild(name)
        if remote then
            local reliable = remote:FindFirstChild("Reliable")
            if reliable then return reliable end
            return remote
        end
    end
    return nil
end

local function GetAttackRemote()
    for _, name in pairs({"RemoteEvent", "AttackRemote", "CombatRemote", "Remote"}) do
        local remote = ReplicatedStorage:FindFirstChild(name)
        if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
            return remote
        end
    end
    return nil
end

local function SafeFire(remote, ...)
    if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
        if stealthMode then wait(0.1) end
        pcall(function()
            remote:FireServer(...)
        end)
    end
end

local function SafeWait()
    if not stealthMode then wait(); return end
    math.randomseed(tick())
    local delay = math.random(20, 50) / 100
    wait(delay)
end

local function SafeCall(func, ...)
    local success, result = pcall(func, ...)
    if not success then warn("SafeCall Error:", result) end
    return success
end

local function CleanupConnections()
    for _, conn in ipairs(safeConnections) do
        pcall(function() conn:Disconnect() end)
    end
    safeConnections = {}
end

local function SafeConnect(signal, callback)
    local conn = signal:Connect(function(...)
        if stealthMode then SafeWait() end
        SafeCall(callback, ...)
    end)
    table.insert(safeConnections, conn)
    return conn
end

local function StartLoop(name, func, interval)
    if activeLoops[name] then activeLoops[name] = false; wait(0.1) end
    activeLoops[name] = true
    spawn(function()
        while activeLoops[name] do
            SafeCall(func)
            if interval then wait(interval) else RunService.Heartbeat:Wait() end
        end
    end)
end

local function StopLoop(name)
    if activeLoops[name] then activeLoops[name] = false end
end

-- ===================================================================
-- IV. GAME LOGIC IMPLEMENTATION
-- ===================================================================

local function ValidatePlayerState()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    return humanoid and humanoid.Health > 0
end

local function EnableAntiAFK()
    local VirtualUser = game:GetService("VirtualUser")
    if not VirtualUser then return end
    if antiAFKConnection then antiAFKConnection:Disconnect() end

    antiAFKConnection = LocalPlayer.Idled:Connect(function()
        SafeCall(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end)
    table.insert(safeConnections, antiAFKConnection)
end

local function DisableAntiAFK()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
    end
end

local function FindEnemiesInRange(range)
    local enemies = {}
    local character = LocalPlayer.Character
    if not character then return enemies end

    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return enemies end

    local playerPos = root.Position

    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("Head") then
            local isPlayer = false
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character == obj then isPlayer = true; break end
            end
            if not isPlayer and obj.Humanoid.Health > 0 then
                local head = obj.Head
                local distance = (playerPos - head.Position).Magnitude
                if distance <= (range or Config.AttackRange) then
                    table.insert(enemies, {
                        Model = obj,
                        Name = obj.Name,
                        Position = head.Position,
                        Distance = distance
                    })
                end
            end
        end
    end

    table.sort(enemies, function(a, b) return a.Distance < b.Distance end)
    return enemies
end

local function GetEnemyGroups()
    local enemies = FindEnemiesInRange(200)
    local groups = {}

    for _, enemy in ipairs(enemies) do
        if not groups[enemy.Name] then
            groups[enemy.Name] = {
                name = enemy.Name,
                count = 0,
                nearestDistance = math.huge
            }
        end
        groups[enemy.Name].count = groups[enemy.Name].count + 1
        if enemy.Distance < groups[enemy.Name].nearestDistance then
            groups[enemy.Name].nearestDistance = enemy.Distance
        end
    end

    return groups
end

local function FarmSelectedLogic()
    if not ValidatePlayerState() or #selectedEnemyNames == 0 then return end

    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    local enemies = FindEnemiesInRange(200)
    local targets = {}
    local remote = GetAttackRemote()
    if not remote then return end

    for _, enemy in ipairs(enemies) do
        for _, selectedName in ipairs(selectedEnemyNames) do
            if enemy.Name == selectedName then
                table.insert(targets, enemy)
                break
            end
        end
    end

    table.sort(targets, function(a, b) return a.Distance < b.Distance end)

    for _, target in ipairs(targets) do
        if not activeLoops["FarmSelected"] then break end

        if target.Model and target.Model.Parent and target.Model:FindFirstChild("Humanoid") and target.Model.Humanoid.Health > 0 then
            local offset = Vector3.new(math.random(-10, 10) / 10, 3, math.random(-10, 10) / 10)
            root.CFrame = CFrame.new(target.Position + offset)

            SafeFire(remote, "Attack", target.Model)
            wait(0.05) 

            if not activeLoops["FarmSelected"] then break end
            SafeFire(remote, "Attack", target.Model)
        end
        wait(0.05)
    end
end

local function AutoAttackLogic()
    if not ValidatePlayerState() then return end
    local enemies = FindEnemiesInRange(Config.AttackRange)
    if #enemies > 0 then
        local nearestEnemy = enemies[1]
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.CFrame = CFrame.new(nearestEnemy.Position + Vector3.new(0, 2, 0))
            local remote = GetAttackRemote()
            if remote then SafeFire(remote, "Attack", nearestEnemy.Model) end
        end
    end
end

local function FarmRandomLogic()
    if not ValidatePlayerState() then return end
    local enemies = FindEnemiesInRange(Config.AttackRange)
    if #enemies > 0 then
        local randomEnemy = enemies[math.random(1, #enemies)]
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.CFrame = CFrame.new(randomEnemy.Position + Vector3.new(0, 2, 0))
            local remote = GetAttackRemote()
            if remote then SafeFire(remote, "Attack", randomEnemy.Model) end
        end
    end
end

local function AutoCollectLogic()
    if not ValidatePlayerState() then return end
    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    local remote = GetAttackRemote()
    if not root or not remote then return end

    local collected = 0
    for _, obj in pairs(workspace:GetDescendants()) do
        if collected >= Config.MaxCollectPerFrame then break end
        if obj:IsA("Part") and (obj.Name:lower():find("drop") or obj.Name:lower():find("coin") or obj.Name:lower():find("reward")) then
            local distance = (root.Position - obj.Position).Magnitude
            if distance < Config.CollectRange then
                SafeFire(remote, "Collect", obj)
                collected = collected + 1
            end
        end
    end
end

local function AutoRebirthLogic()
    if not ValidatePlayerState() then return end
    local remote = GetReplyRemote()
    if remote then SafeFire(remote, "RankUp") end
end

local function AutoOpenEggLogic()
    if not ValidatePlayerState() then return end
    local remote = GetReplyRemote()
    if remote then SafeFire(remote, "Open Star", {[1] = "Egg"}) end
end

local function StartGacha(gachaType)
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Crate Roll Start", {[1] = gachaType, [2] = true})
        wait(1)
        SafeFire(remote, "Crate Roll Stop")
    end
end

local function DistributeStat(statName)
    local remote = GetReplyRemote()
    if remote then SafeFire(remote, "Distribute Stat Point", {[1] = statName}) end
end

local function TeleportToZone(zoneKey)
    local zoneName = Config.Zones[zoneKey]
    if not zoneName then return end
    local remote = GetReplyRemote()
    if remote then SafeFire(remote, "Zone Teleport", {[1] = zoneName}) end
end

local function SafeTeleportToZone(zoneKey)
    if tick() - lastTeleportTime < Config.TeleportCooldown then return end
    TeleportToZone(zoneKey)
    lastTeleportTime = tick()
end

local function StartAutoRollLoop(gachaName)
    local loopName = "AutoRoll"..gachaName
    
    for name, _ in pairs(activeLoops) do
        if name:find("AutoRoll") then StopLoop(name) end
    end
    
    StartLoop(loopName, function() StartGacha(gachaName) end, 2)
end

-- ===================================================================
-- V. DUNGEON FUNCTIONS
-- ===================================================================

local function SaveAndStopFarmLoops()
    wasAutoAttackEnabled = activeLoops["AutoAttack"] or false
    wasFarmSelectedEnabled = activeLoops["FarmSelected"] or false
    wasFarmRandomEnabled = activeLoops["FarmRandom"] or false
    wasAutoCollectEnabled = activeLoops["AutoCollect"] or false
    
    StopLoop("AutoAttack")
    StopLoop("FarmSelected")
    StopLoop("FarmRandom")
    StopLoop("AutoCollect")
end

local function RestoreFarmLoops()
    if wasAutoAttackEnabled then StartLoop("AutoAttack", AutoAttackLogic, 0.3) end
    if wasFarmSelectedEnabled then StartLoop("FarmSelected", FarmSelectedLogic, 0.5) end
    if wasFarmRandomEnabled then StartLoop("FarmRandom", FarmRandomLogic, 0.5) end
    if wasAutoCollectEnabled then StartLoop("AutoCollect", AutoCollectLogic, 1.0) end
    
    print("‚úÖ ƒê√£ kh√¥i ph·ª•c c√†i ƒë·∫∑t Farm map c≈©.")
    wasAutoAttackEnabled = false
    wasFarmSelectedEnabled = false
    wasFarmRandomEnabled = false
    wasAutoCollectEnabled = false
end

local function AutoJoinDungeonEasyLogic()
    lastZone = selectedZone 
    
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Join Gamemode", {[1] = "Dungeon:1"})
        print("üó∫Ô∏è ƒê√£ g·ª≠i y√™u c·∫ßu tham gia Dungeon Easy!")
    end
end

local function AutoFarmDungeonLogic()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then 
        isPlayerInDungeon = false
        return 
    end

    local enemies = FindEnemiesInRange(200)
    if #enemies > 0 then
        isPlayerInDungeon = true 
        local nearestEnemy = enemies[1]
        
        character.HumanoidRootPart.CFrame = CFrame.new(nearestEnemy.Position + Vector3.new(0,5,0))
        
        local remote = GetAttackRemote()
        if remote then 
            SafeFire(remote, "Attack", nearestEnemy.Model) 
        end
    else
        isPlayerInDungeon = false
    end
end

local function DungeonExitCheck()
    if isDungeonActive and not isPlayerInDungeon and not activeLoops["AutoJoinDungeon"] and not activeLoops["AutoFarmDungeon"] then
        StopLoop("DungeonExitLoop")
        
        isDungeonActive = false
        autoDungeonFarmEnabled = false
        
        print("üö™ ƒê√£ tho√°t Dungeon. Quay v·ªÅ Zone c≈©: " .. lastZone)
        TeleportToZone(lastZone)
        
        RestoreFarmLoops()
        
        StartLoop("DungeonExitLoop", DungeonExitCheck, 5)
    end
end

-- ===================================================================
-- VI. SAVE/LOAD CONFIG
-- ===================================================================

local function SaveConfig()
    local data = {
        selectedEnemyNames = selectedEnemyNames,
        selectedGachaType = selectedGachaType,
        selectedZone = selectedZone,
        selectedStat = selectedStat,
        autoOpenEggEnabled = autoOpenEggEnabled,
        stealthMode = stealthMode,
        
        selectedFarmEnabled = activeLoops["FarmSelected"] or false,
        autoAttackEnabled = activeLoops["AutoAttack"] or false,
        farmRandomEnabled = activeLoops["FarmRandom"] or false,
        autoCollectEnabled = activeLoops["AutoCollect"] or false,
        stealthModeEnabled = stealthMode,
        antiAFKEnabled = antiAFKEnabled
    }
    local encoded = HttpService:JSONEncode(data)
    writefile(configFile, encoded)
end

local function LoadConfig()
    if isfile(configFile) then
        local success, data = pcall(function()
            local encoded = readfile(configFile)
            return HttpService:JSONDecode(encoded)
        end)
        if success and data then
            selectedEnemyNames = data.selectedEnemyNames or {}
            selectedGachaType = data.selectedGachaType or Config.GachaTypes[1]
            selectedZone = data.selectedZone or sortedZoneKeys[1]
            selectedStat = data.selectedStat or Config.StatTypes[1]
            stealthMode = data.stealthMode or Config.StealthMode
            antiAFKEnabled = data.antiAFKEnabled or true

            selectedFarmEnabled = data.selectedFarmEnabled or false
            autoAttackEnabled = data.autoAttackEnabled or false
            farmRandomEnabled = data.farmRandomEnabled or false
            autoCollectEnabled = data.autoCollectEnabled or false
            stealthModeEnabled = data.stealthModeEnabled or Config.StealthMode
            autoOpenEggEnabled = data.autoOpenEggEnabled or false
        end
    end
end

local function DeleteConfig()
    if isfile(configFile) then delfile(configFile) end
end

-- ===================================================================
-- VII. MODERN UI FRAMEWORK
-- ===================================================================

local COLOR_BACKGROUND = Color3.fromRGB(25, 25, 35)
local COLOR_SIDEBAR = Color3.fromRGB(35, 35, 50)
local COLOR_CARD = Color3.fromRGB(45, 45, 60)
local COLOR_ACCENT = Color3.fromRGB(0, 170, 255)
local COLOR_TEXT = Color3.fromRGB(240, 240, 240)
local COLOR_TEXT_DIM = Color3.fromRGB(180, 180, 200)
local COLOR_ON = Color3.fromRGB(0, 200, 100)
local COLOR_OFF = Color3.fromRGB(200, 60, 60)

local function CreatePanel(size, position, parent, color)
    local panel = Instance.new("Frame")
    panel.Size = size
    panel.Position = position
    panel.BackgroundColor3 = color or COLOR_CARD
    panel.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = panel
    
    return panel
end

local function CreateLabel(text, size, position, parent, bold, fontSize, color, alignment)
    local label = Instance.new("TextLabel")
    label.Size = size
    label.Position = position
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = color or COLOR_TEXT
    label.Font = bold and Enum.Font.GothamBold or Enum.Font.Gotham
    label.TextSize = fontSize or 14
    label.TextXAlignment = alignment or Enum.TextXAlignment.Left
    label.Parent = parent
    return label
end

local function UpdateToggleButton(toggleFrame, enabled)
    local toggleBtn = toggleFrame:FindFirstChildOfClass("TextButton")
    if toggleBtn then
        toggleBtn.Text = enabled and "ON" or "OFF"
        toggleBtn.BackgroundColor3 = enabled and COLOR_ON or COLOR_OFF
    end
end

function CreateToggleSwitch(text, description, default, callback)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, -20, 0, 60)
    frame.BackgroundTransparency = 1

    local label = CreateLabel(text, UDim2.new(0.7, 0, 0.5, 0), UDim2.new(0, 10, 0, 0), frame, true, 14)
    local desc = CreateLabel(description, UDim2.new(0.7, 0, 0.5, 0), UDim2.new(0, 10, 0.5, 0), frame, false, 12, COLOR_TEXT_DIM)

    local toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.Size = UDim2.new(0, 65, 0, 28)
    toggleButton.Position = UDim2.new(1, -75, 0.5, -14)
    toggleButton.TextColor3 = COLOR_TEXT
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 13
    toggleButton.Parent = frame

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = toggleButton
    
    local isOn = default

    SafeConnect(toggleButton.MouseButton1Click, function()
        isOn = not isOn
        UpdateToggleButton(frame, isOn)
        callback(isOn)
    end)

    UpdateToggleButton(frame, default)

    return frame
end

function CreateActionButton(text, description, callback)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, -20, 0, 50)
    frame.BackgroundTransparency = 1
    
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.4, 0, 0, 32)
    btn.Position = UDim2.new(0, 0, 0.5, -16)
    btn.BackgroundColor3 = COLOR_ACCENT
    btn.Text = text
    btn.TextColor3 = COLOR_TEXT
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 13
    btn.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = btn

    local desc = CreateLabel(description, UDim2.new(0.5, 0, 0.5, 0), UDim2.new(0.4, 20, 0.5, -10), frame, false, 11, COLOR_TEXT_DIM)
    desc.TextXAlignment = Enum.TextXAlignment.Left

    SafeConnect(btn.MouseButton1Click, function()
        if callback then callback() end
    end)

    return frame
end

function CreateComboBox(text, description, items, callback)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, -20, 0, 60)
    frame.BackgroundTransparency = 1
    
    local label = CreateLabel(text, UDim2.new(0.5, 0, 0.5, 0), UDim2.new(0, 0, 0, 5), frame, true, 14)
    local desc = CreateLabel(description, UDim2.new(0.5, 0, 0.5, 0), UDim2.new(0, 0, 0.5, 0), frame, false, 11, COLOR_TEXT_DIM)

    local dropdown = Instance.new("TextButton")
    dropdown.Size = UDim2.new(0.4, 0, 0, 32)
    dropdown.Position = UDim2.new(0.55, 0, 0.25, 0)
    dropdown.BackgroundColor3 = COLOR_SIDEBAR
    dropdown.Text = items[1] or "Select"
    dropdown.TextColor3 = COLOR_TEXT
    dropdown.Font = Enum.Font.GothamBold
    dropdown.TextSize = 13
    dropdown.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = dropdown

    local selected = items[1]
    
    SafeConnect(dropdown.MouseButton1Click, function()
        local menu = Instance.new("ScrollingFrame")
        menu.Size = UDim2.new(0.4, 0, 0, math.min(#items * 28, 200))
        menu.Position = UDim2.new(0.55, 0, 0.75, 0)
        menu.BackgroundColor3 = COLOR_SIDEBAR
        menu.ZIndex = 5
        menu.CanvasSize = UDim2.new(0, 0, 0, #items * 28)
        menu.Parent = frame

        local listLayout = Instance.new("UIListLayout")
        listLayout.Padding = UDim.new(0, 2)
        listLayout.Parent = menu

        local menuCorner = Instance.new("UICorner")
        menuCorner.CornerRadius = UDim.new(0, 6)
        menuCorner.Parent = menu

        for i, item in ipairs(items) do
            local itemBtn = Instance.new("TextButton")
            itemBtn.Size = UDim2.new(1, 0, 0, 28)
            itemBtn.BackgroundColor3 = (item == selected) and COLOR_ACCENT or COLOR_SIDEBAR
            itemBtn.Text = item
            itemBtn.TextColor3 = COLOR_TEXT
            itemBtn.Font = Enum.Font.Gotham
            itemBtn.TextSize = 12
            itemBtn.Parent = menu
            
            SafeConnect(itemBtn.MouseButton1Click, function()
                dropdown.Text = item
                selected = item
                menu:Destroy()
                if callback then callback(item) end
            end)
        end
    end)

    return frame
end

-- ===================================================================
-- VIII. GUI CONSTRUCTION
-- ===================================================================

local function ToggleUI(showMain)
    if showMain then
        HimonoHub.Enabled = true
        HimonoMini.Enabled = false
    else
        HimonoHub.Enabled = false
        HimonoMini.Enabled = true
    end
end

-- Mini UI Setup
HimonoMini = Instance.new("ScreenGui")
HimonoMini.Name = "HimonoHubMini"
HimonoMini.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
HimonoMini.Enabled = false
HimonoMini.Parent = game.CoreGui

MiniButton = Instance.new("TextButton")
MiniButton.Name = "MiniButton"
MiniButton.Size = UDim2.new(0, 50, 0, 50)
MiniButton.Position = UDim2.new(1, -60, 0, 20)
MiniButton.BackgroundColor3 = COLOR_ACCENT
MiniButton.Text = "üî∑"
MiniButton.TextColor3 = COLOR_TEXT
MiniButton.Font = Enum.Font.GothamBold
MiniButton.TextSize = 20
MiniButton.Parent = HimonoMini

local MiniCorner = Instance.new("UICorner")
MiniCorner.CornerRadius = UDim.new(0, 12)
MiniCorner.Parent = MiniButton

SafeConnect(MiniButton.MouseButton1Click, function()
    ToggleUI(true)
end)

-- Main UI Setup
HimonoHub = Instance.new("ScreenGui")
HimonoHub.Name = "HimonoHubModern"
HimonoHub.ResetOnSpawn = false
HimonoHub.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
HimonoHub.Parent = game.CoreGui

MainContainer = CreatePanel(UDim2.new(0, 900, 0, 600), UDim2.new(0.5, -450, 0.5, -300), HimonoHub, COLOR_BACKGROUND)

-- TitleBar Setup
TitleBar = CreatePanel(UDim2.new(1, 0, 0, 50), UDim2.new(0, 0, 0, 0), MainContainer, COLOR_SIDEBAR)

local Title = CreateLabel("üî∑ HIMONO HUB v5.0 - MODERN EDITION", UDim2.new(1, -100, 1, 0), UDim2.new(0, 20, 0, 0), TitleBar, true, 18, COLOR_ACCENT)

local StealthIndicator = Instance.new("Frame")
StealthIndicator.Name = "StealthIndicator"
StealthIndicator.Size = UDim2.new(0, 12, 0, 12)
StealthIndicator.Position = UDim2.new(1, -80, 0.5, -6)
StealthIndicator.BackgroundColor3 = stealthMode and COLOR_ON or COLOR_OFF
StealthIndicator.Parent = TitleBar

local StealthCorner = Instance.new("UICorner")
StealthCorner.CornerRadius = UDim.new(1, 0)
StealthCorner.Parent = StealthIndicator

local StealthLabel = CreateLabel(stealthMode and "STEALTH: ON" or "STEALTH: OFF", UDim2.new(0, 70, 1, 0), UDim2.new(1, -70, 0, 0), TitleBar, false, 11, stealthMode and COLOR_ON or COLOR_OFF, Enum.TextXAlignment.Right)

-- Hide Button
local HideButton = Instance.new("TextButton")
HideButton.Name = "HideButton"
HideButton.Size = UDim2.new(0, 30, 0, 30)
HideButton.Position = UDim2.new(1, -35, 0.5, -15)
HideButton.BackgroundColor3 = COLOR_ACCENT
HideButton.Text = "‚îÄ"
HideButton.TextColor3 = COLOR_TEXT
HideButton.Font = Enum.Font.GothamBold
HideButton.TextSize = 16
HideButton.Parent = TitleBar

local HideCorner = Instance.new("UICorner")
HideCorner.CornerRadius = UDim.new(0, 6)
HideCorner.Parent = HideButton

SafeConnect(HideButton.MouseButton1Click, function()
    ToggleUI(false)
end)

-- Sidebar
local Sidebar = CreatePanel(UDim2.new(0, 200, 1, -50), UDim2.new(0, 0, 0, 50), MainContainer, COLOR_SIDEBAR)

-- Main Content Area
local ContentArea = CreatePanel(UDim2.new(1, -200, 1, -50), UDim2.new(0, 200, 0, 50), MainContainer, COLOR_BACKGROUND)

local ContentScroll = Instance.new("ScrollingFrame")
ContentScroll.Size = UDim2.new(1, -20, 1, -20)
ContentScroll.Position = UDim2.new(0, 10, 0, 10)
ContentScroll.BackgroundTransparency = 1
ContentScroll.ScrollBarThickness = 5
ContentScroll.ScrollBarImageColor3 = COLOR_ACCENT
ContentScroll.CanvasSize = UDim2.new(0, 0, 2, 0)
ContentScroll.Parent = ContentArea

local ContentLayout = Instance.new("UIGridLayout")
ContentLayout.CellSize = UDim2.new(0.5, -10, 0, 180)
ContentLayout.CellPadding = UDim2.new(0, 10, 0, 10)
ContentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
ContentLayout.SortOrder = Enum.SortOrder.LayoutOrder
ContentLayout.Parent = ContentScroll

-- Tab System
local tabs = {
    {Name = "üè† MAIN", Icon = "üè†"},
    {Name = "üåæ FARM", Icon = "üåæ"},
    {Name = "üó∫Ô∏è DUNGEON", Icon = "üó∫Ô∏è"},
    {Name = "üé∞ GACHA", Icon = "üé∞"},
    {Name = "‚ö° STATS", Icon = "‚ö°"},
    {Name = "üöÄ TELEPORT", Icon = "üöÄ"},
    {Name = "ü•ö EGG", Icon = "ü•ö"},
    {Name = "‚öôÔ∏è SETTINGS", Icon = "‚öôÔ∏è"}
}

local tabFrames = {}
local currentTab = "üè† MAIN"

for i, tab in ipairs(tabs) do
    local tabButton = Instance.new("TextButton")
    tabButton.Size = UDim2.new(1, -20, 0, 50)
    tabButton.Position = UDim2.new(0, 10, 0, 10 + (i-1)*60)
    tabButton.BackgroundColor3 = tab.Name == currentTab and COLOR_ACCENT or COLOR_SIDEBAR
    tabButton.Text = "   " .. tab.Icon .. " " .. tab.Name
    tabButton.TextColor3 = COLOR_TEXT
    tabButton.Font = Enum.Font.GothamBold
    tabButton.TextSize = 14
    tabButton.TextXAlignment = Enum.TextXAlignment.Left
    tabButton.Parent = Sidebar

    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 6)
    tabCorner.Parent = tabButton

    local contentFrame = Instance.new("Frame")
    contentFrame.Size = UDim2.new(1, 0, 1, 0)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Visible = tab.Name == currentTab
    contentFrame.Parent = ContentScroll
    contentFrame.Name = tab.Name

    tabFrames[tab.Name] = contentFrame

    SafeConnect(tabButton.MouseButton1Click, function()
        currentTab = tab.Name
        for name, frame in pairs(tabFrames) do
            frame.Visible = (name == currentTab)
        end
        for _, btn in pairs(Sidebar:GetChildren()) do
            if btn:IsA("TextButton") then
                btn.BackgroundColor3 = (btn.Text:find(currentTab)) and COLOR_ACCENT or COLOR_SIDEBAR
            end
        end
    end)
end

-- ===================================================================
-- IX. TAB CONTENT
-- ===================================================================

-- MAIN TAB
local mainContent = tabFrames["üè† MAIN"]

CreateLabel("CORE AUTOMATION", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), mainContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local autoAttackToggle = CreateToggleSwitch(
    "Auto Attack (Nearest)", 
    "T·ª± ƒë·ªông t·∫•n c√¥ng k·∫ª ƒë·ªãch g·∫ßn nh·∫•t", 
    autoAttackEnabled,
    function(enabled)
        autoAttackEnabled = enabled
        if enabled then StartLoop("AutoAttack", AutoAttackLogic, Config.FarmInterval) else StopLoop("AutoAttack") end
    end
)
autoAttackToggle.Parent = mainContent

local autoCollectToggle = CreateToggleSwitch(
    "Auto Collect All Drops", 
    "T·ª± ƒë·ªông nh·∫∑t v·∫≠t ph·∫©m quanh b·∫°n", 
    autoCollectEnabled,
    function(enabled)
        autoCollectEnabled = enabled
        if enabled then StartLoop("AutoCollect", AutoCollectLogic, 1.0) else StopLoop("AutoCollect") end
    end
)
autoCollectToggle.Parent = mainContent

local autoRebirthToggle = CreateToggleSwitch(
    "Auto Rebirth", 
    "T·ª± ƒë·ªông RankUp/Rebirth khi c√≥ th·ªÉ", 
    false,
    function(enabled)
        if enabled then StartLoop("AutoRebirth", AutoRebirthLogic, 10) else StopLoop("AutoRebirth") end
    end
)
autoRebirthToggle.Parent = mainContent

-- FARM TAB
local farmContent = tabFrames["üåæ FARM"]

CreateLabel("FARMING METHODS", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), farmContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local farmSelectedToggle = CreateToggleSwitch(
    "Auto Farm Selected Enemies", 
    "Farm T·∫§T C·∫¢ enemy c√πng t√™n (Burst Attack)", 
    selectedFarmEnabled,
    function(enabled)
        selectedFarmEnabled = enabled
        if enabled then StartLoop("FarmSelected", FarmSelectedLogic, Config.FarmInterval) else StopLoop("FarmSelected") end
    end
)
farmSelectedToggle.Parent = farmContent

local farmRandomToggle = CreateToggleSwitch(
    "Farm Random Enemies", 
    "T·ª± ƒë·ªông Teleport v√† farm ng·∫´u nhi√™n", 
    farmRandomEnabled,
    function(enabled)
        farmRandomEnabled = enabled
        if enabled then StartLoop("FarmRandom", FarmRandomLogic, Config.FarmInterval) else StopLoop("FarmRandom") end
    end
)
farmRandomToggle.Parent = farmContent

-- Enemy Selector
CreateLabel("ENEMY SELECTOR", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), farmContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local enemyGroups = GetEnemyGroups()
local enemyNames = {}
for name, _ in pairs(enemyGroups) do table.insert(enemyNames, name) end
table.sort(enemyNames)

local enemyCombo = CreateComboBox("Select Enemies to Farm", "Ch·ªçn k·∫ª ƒë·ªãch ƒë·ªÉ farm", enemyNames, function(selected)
    if not table.find(selectedEnemyNames, selected) then
        table.insert(selectedEnemyNames, selected)
        print("‚úÖ ƒê√£ ch·ªçn enemy: " .. selected)
    end
end)
enemyCombo.Parent = farmContent

local clearEnemiesBtn = CreateActionButton("Clear Selected (" .. #selectedEnemyNames .. "x)", "X√≥a t·∫•t c·∫£ k·∫ª ƒë·ªãch ƒë√£ ch·ªçn", function()
    selectedEnemyNames = {}
    print("üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ enemy ƒë√£ ch·ªçn")
end)
clearEnemiesBtn.Parent = farmContent

-- DUNGEON TAB
local dungeonContent = tabFrames["üó∫Ô∏è DUNGEON"]

CreateLabel("DUNGEON AUTOMATION", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), dungeonContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local autoJoinDungeonToggle = CreateToggleSwitch(
    "Auto Join Dungeon Easy", 
    "T·ª± ƒë·ªông g·ª≠i y√™u c·∫ßu v√†o Dungeon Easy", 
    false,
    function(enabled)
        if enabled then 
            isDungeonActive = true
            SaveAndStopFarmLoops()
            StartLoop("AutoJoinDungeon", AutoJoinDungeonEasyLogic, 15)
        else 
            StopLoop("AutoJoinDungeon")
            isDungeonActive = activeLoops["AutoFarmDungeon"] or false
            if not isDungeonActive then 
                RestoreFarmLoops()
            end
        end
    end
)
autoJoinDungeonToggle.Parent = dungeonContent

local autoFarmDungeonToggle = CreateToggleSwitch(
    "Auto Farm Dungeon", 
    "T·ª± ƒë·ªông Teleport v√† farm qu√°i trong Dungeon", 
    false,
    function(enabled)
        autoDungeonFarmEnabled = enabled
        if enabled then 
            isDungeonActive = true
            SaveAndStopFarmLoops()
            StartLoop("AutoFarmDungeon", AutoFarmDungeonLogic, 0.4)
        else 
            StopLoop("AutoFarmDungeon")
            isDungeonActive = activeLoops["AutoJoinDungeon"] or false
            if not isDungeonActive then 
                RestoreFarmLoops()
            end
        end
    end
)
autoFarmDungeonToggle.Parent = dungeonContent

-- GACHA TAB
local gachaContent = tabFrames["üé∞ GACHA"]

CreateLabel("GACHA AUTOMATION", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), gachaContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local gachaCombo = CreateComboBox("Select Gacha", "Ch·ªçn lo·∫°i gacha ƒë·ªÉ auto roll", Config.GachaTypes, function(selected)
    selectedGachaType = selected
end)
gachaCombo.Parent = gachaContent

for i, gacha in ipairs(Config.GachaTypes) do
    local toggle = CreateToggleSwitch(
        "Auto Roll: " .. gacha,
        "T·ª± ƒë·ªông roll " .. gacha .. " (Loop 2s)",
        false,
        function(enabled)
            if enabled then
                StartAutoRollLoop(gacha)
            else
                StopLoop("AutoRoll"..gacha)
            end
        end
    )
    toggle.Parent = gachaContent
end

-- STATS TAB
local statsContent = tabFrames["‚ö° STATS"]

CreateLabel("STAT DISTRIBUTION", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), statsContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local statCombo = CreateComboBox("Select Stat", "Ch·ªçn lo·∫°i stat ƒë·ªÉ c·ªông ƒëi·ªÉm", Config.StatTypes, function(selected)
    selectedStat = selected
end)
statCombo.Parent = statsContent

local distributeBtn = CreateActionButton("Distribute Stat Point", "C·ªông 1 ƒëi·ªÉm v√†o stat ƒë√£ ch·ªçn", function()
    DistributeStat(selectedStat)
end)
distributeBtn.Parent = statsContent

-- TELEPORT TAB
local teleportContent = tabFrames["üöÄ TELEPORT"]

CreateLabel("ZONE TELEPORT", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), teleportContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local zoneCombo = CreateComboBox("Select Destination", "Di chuy·ªÉn nhanh ƒë·∫øn khu v·ª±c", sortedZoneKeys, function(selected)
    selectedZone = selected
end)
zoneCombo.Parent = teleportContent

local teleportBtn = CreateActionButton("TELEPORT NOW", "Di chuy·ªÉn ƒë·∫øn khu v·ª±c ƒë√£ ch·ªçn", function()
    SafeTeleportToZone(selectedZone)
end)
teleportBtn.Parent = teleportContent

-- EGG TAB
local eggContent = tabFrames["ü•ö EGG"]

CreateLabel("EGG HATCHING", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), eggContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local openEggBtn = CreateActionButton("Manual Open Egg", "M·ªü egg g·∫ßn b·∫°n m·ªôt l·∫ßn", function()
    AutoOpenEggLogic()
end)
openEggBtn.Parent = eggContent

local autoOpenEggToggle = CreateToggleSwitch(
    "Enable Auto Open Egg",
    "T·ª± ƒë·ªông m·ªü egg khi g·∫ßn (Loop 2s)",
    autoOpenEggEnabled,
    function(enabled)
        autoOpenEggEnabled = enabled
        if enabled then
            StartLoop("AutoOpenEgg", AutoOpenEggLogic, 2)
        else
            StopLoop("AutoOpenEgg")
        end
    end
)
autoOpenEggToggle.Parent = eggContent

-- SETTINGS TAB
local settingsContent = tabFrames["‚öôÔ∏è SETTINGS"]

CreateLabel("SYSTEM SETTINGS", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 10), settingsContent, true, 16, COLOR_ACCENT, Enum.TextXAlignment.Left)

local antiAfkToggle = CreateToggleSwitch(
    "Enable Anti-AFK",
    "Ch·ªëng b·ªã kick khi treo m√°y",
    antiAFKEnabled,
    function(enabled)
        antiAFKEnabled = enabled
        if enabled then EnableAntiAFK() else DisableAntiAFK() end
    end
)
antiAfkToggle.Parent = settingsContent

local stealthToggle = CreateToggleSwitch(
    "Enable Stealth Mode",
    "Gi·∫£m t·ªëc ƒë·ªô Remote Calls ƒë·ªÉ tr√°nh b·ªã ph√°t hi·ªán",
    stealthModeEnabled,
    function(enabled)
        stealthMode = enabled
        stealthModeEnabled = enabled
        StealthIndicator.BackgroundColor3 = enabled and COLOR_ON or COLOR_OFF
        StealthLabel.Text = enabled and "STEALTH: ON" or "STEALTH: OFF"
        StealthLabel.TextColor3 = enabled and COLOR_ON or COLOR_OFF
    end
)
stealthToggle.Parent = settingsContent

local saveBtn = CreateActionButton("Save Config", "L∆∞u l·∫°i c·∫•u h√¨nh hi·ªán t·∫°i", function()
    SaveConfig()
    print("üíæ ƒê√£ l∆∞u c·∫•u h√¨nh!")
end)
saveBtn.Parent = settingsContent

local loadBtn = CreateActionButton("Load Config", "T·∫£i l·∫°i c·∫•u h√¨nh ƒë√£ l∆∞u", function()
    LoadConfig()
    ApplyLoadedConfig()
    print("üìÇ ƒê√£ t·∫£i c·∫•u h√¨nh!")
end)
loadBtn.Parent = settingsContent

-- ===================================================================
-- X. DRAG & INITIALIZATION
-- ===================================================================

local dragging, dragInput, dragStart, startPos

SafeConnect(TitleBar.InputBegan, function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MainContainer.Position
    end
end)

SafeConnect(TitleBar.InputChanged, function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

SafeConnect(TitleBar.InputEnded, function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

SafeConnect(UserInputService.InputChanged, function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        MainContainer.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

SafeConnect(UserInputService.InputBegan, function(input, gameProcessedEvent)
    if input.KeyCode == Enum.KeyCode.RightControl and not gameProcessedEvent then
        ToggleUI(not HimonoHub.Enabled)
    end
end)

-- Apply loaded config function
local function ApplyLoadedConfig()
    for name in pairs(activeLoops) do StopLoop(name) end
    
    UpdateToggleButton(autoAttackToggle, autoAttackEnabled)
    UpdateToggleButton(farmSelectedToggle, selectedFarmEnabled)
    UpdateToggleButton(farmRandomToggle, farmRandomEnabled)
    UpdateToggleButton(autoCollectToggle, autoCollectEnabled)
    UpdateToggleButton(stealthToggle, stealthModeEnabled)
    UpdateToggleButton(antiAfkToggle, antiAFKEnabled)
    UpdateToggleButton(autoOpenEggToggle, autoOpenEggEnabled)

    if autoAttackEnabled then StartLoop("AutoAttack", AutoAttackLogic, Config.FarmInterval) end
    if selectedFarmEnabled then StartLoop("FarmSelected", FarmSelectedLogic, Config.FarmInterval) end
    if farmRandomEnabled then StartLoop("FarmRandom", FarmRandomLogic, Config.FarmInterval) end
    if autoCollectEnabled then StartLoop("AutoCollect", AutoCollectLogic, 1.0) end
    if autoOpenEggEnabled then StartLoop("AutoOpenEgg", AutoOpenEggLogic, 2) end

    if antiAFKEnabled then EnableAntiAFK() else DisableAntiAFK() end

    stealthMode = stealthModeEnabled
    StealthIndicator.BackgroundColor3 = stealthMode and COLOR_ON or COLOR_OFF
    StealthLabel.Text = stealthMode and "STEALTH: ON" or "STEALTH: OFF"
    StealthLabel.TextColor3 = stealthMode and COLOR_ON or COLOR_OFF
end

-- Auto-adjust canvas size
spawn(function()
    while HimonoHub.Parent do
        wait(0.5)
        for _, frame in pairs(tabFrames) do
            local ySize = 0
            for _, child in pairs(frame:GetChildren()) do
                if child:IsA("Frame") then
                    ySize = ySize + child.Size.Y.Offset + 10
                end
            end
            ContentScroll.CanvasSize = UDim2.new(0, 0, 0, ySize + 20)
        end
    end
end)

-- Start Dungeon exit check
StartLoop("DungeonExitLoop", DungeonExitCheck, 5)

-- Initialize
LoadConfig()
ApplyLoadedConfig()
EnableAntiAFK()

print("üî∑ HIMONO HUB v5.0 - MODERN EDITION LOADED! (Dungeon & Farm System Ready)")
