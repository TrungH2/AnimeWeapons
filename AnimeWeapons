local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- ===================================================================
-- I. CONFIGURATION
-- ===================================================================

local Config = {
    StealthMode = true,
    AttackRange = 50, 
    CollectRange = 20, 
    EnemyRefreshRate = 0.5,
    RebirthCheckInterval = 10,
    DungeonJoinInterval = 15,
    TeleportCooldown = 2,
    MaxCollectPerFrame = 10,
    FarmInterval = 0.1,
    RemotePatterns = {
        Reply = {"Reply"},
        Attack = {"RemoteEvent", "Remote"}
    },
    Zones = {
        ["Shinobi Village"] = "Naruto",
        ["Namek Planet"] = "DragonBall",
        ["Desert Land"] = "OnePiece",
        ["Demon Land"] = "DemonSlayer",
        ["Dungeon Easy"] = "Dungeon:1",
        ["Dungeon Teleport"] = "Dungeon", 
        ["Zone 1"] = "Zone 1", 
        ["Zone 2"] = "Zone 2", 
        ["Zone 3"] = "Zone 3", 
        ["Zone 4"] = "Zone 4", 
    },
    StatTypes = {"Damage", "Mastery", "Luck", "Yen"},
    GachaTypes = {"Biju", "Race", "Sayajin", "Haki", "Fruits"},
}

local sortedZoneKeys = {}
for key, _ in pairs(Config.Zones) do table.insert(sortedZoneKeys, key) end
table.sort(sortedZoneKeys)

-- ===================================================================
-- II. STATE VARIABLES
-- ===================================================================

local stealthMode = Config.StealthMode
local safeConnections = {}
local activeLoops = {}
local selectedEnemyPositions = {}
local selectedGachaType = Config.GachaTypes[1] or "Biju"
local selectedStat = Config.StatTypes[1] or "Damage"
local selectedZone = sortedZoneKeys[1] or "Zone 1"
local isDungeonActive = false
local autoDungeonFarmEnabled = false
local isPlayerInDungeon = false
local wasAutoAttackEnabled = false
local wasFarmSelectedEnabled = false
local wasFarmRandomEnabled = false
local wasAutoCollectEnabled = false
local lastZone = selectedZone
local cachedEnemies = {}
local lastEnemyRefresh = 0
local lastTeleportTime = 0 

-- ===================================================================
-- III. CORE UTILITIES
-- ===================================================================

local function GetReplyRemote()
    local replyRemote = ReplicatedStorage:FindFirstChild(Config.RemotePatterns.Reply[1])
    if replyRemote then
        return replyRemote:FindFirstChild("Reliable")
    end
    return nil
end

local function GetAttackRemote()
    for _, name in ipairs(Config.RemotePatterns.Attack) do
        local remote = ReplicatedStorage:FindFirstChild(name)
        if remote then return remote end
    end
    return nil
end

local function SafeFire(remote, ...)
    if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
        if stealthMode then RunService.Heartbeat:Wait() end
        remote:FireServer(...)
    end
end

local function SafeWait()
    if not stealthMode then task.wait(); return end
    math.randomseed(tick())
    local delay = math.random(20, 50) / 100
    local start = tick()
    while tick() - start < delay do RunService.Heartbeat:Wait() end
end

local function SafeCall(func, ...)
    local success, result = pcall(func, ...)
    if not success then warn("SafeCall Error in:", func, result) end
    return success and result or nil
end

local function SafeConnect(signal, callback)
    local conn = signal:Connect(function(...)
        if stealthMode then SafeWait() end
        SafeCall(callback, ...)
    end)
    table.insert(safeConnections, conn)
    return conn
end

local function StartLoop(name, func, interval)
    if activeLoops[name] then StopLoop(name) end
    activeLoops[name] = true
    task.spawn(function()
        while activeLoops[name] do
            pcall(func)
            if interval then task.wait(interval) else RunService.Heartbeat:Wait() end
        end
    end)
end

local function StopLoop(name)
    if activeLoops[name] then activeLoops[name] = false end
end

local function SaveAndStopFarmLoops()
    wasAutoAttackEnabled = activeLoops["AutoAttack"] or false
    wasFarmSelectedEnabled = activeLoops["FarmSelected"] or false
    wasFarmRandomEnabled = activeLoops["FarmRandom"] or false
    wasAutoCollectEnabled = activeLoops["AutoCollect"] or false
    
    StopLoop("AutoAttack")
    StopLoop("FarmSelected")
    StopLoop("FarmRandom")
    StopLoop("AutoCollect")
end

local function RestoreFarmLoops()
    if wasAutoAttackEnabled then StartLoop("AutoAttack", AutoAttackLogic, Config.FarmInterval) end
    if wasFarmSelectedEnabled then StartLoop("FarmSelected", FarmSelectedLogic, Config.FarmInterval) end
    if wasFarmRandomEnabled then StartLoop("FarmRandom", FarmRandomLogic, Config.FarmInterval) end
    if wasAutoCollectEnabled then StartLoop("AutoCollect", AutoCollectLogic, 1.0) end
    
    print("‚úÖ ƒê√£ kh√¥i ph·ª•c c√†i ƒë·∫∑t Farm map c≈©.")
end

-- ===================================================================
-- IV. GAME LOGIC IMPLEMENTATION (ƒê√É S·ª¨A L·ªñI)
-- ===================================================================

local function ValidatePlayerState()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Humanoid") or character.Humanoid.Health <= 0 then
        return false
    end
    return true
end

local function GetCharacterRootPart()
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        return character.HumanoidRootPart
    end
    return nil
end

local function EnableAntiAFK()
    local VirtualUser = game:GetService("VirtualUser")
    if not VirtualUser then return end

    local antiAFKConnection
    if antiAFKConnection then antiAFKConnection:Disconnect() end
    antiAFKConnection = LocalPlayer.Idled:Connect(function()
        SafeCall(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end)
end

local function FindEnemiesInRange(range)
    local currentTime = tick()
    local rootPart = GetCharacterRootPart()
    if not rootPart then return {} end
    local playerPos = rootPart.Position

    if currentTime - lastEnemyRefresh < Config.EnemyRefreshRate then
        local livingEnemies = {}
        for i, enemyData in ipairs(cachedEnemies) do
            local enemyModel = enemyData.Model
            if enemyModel and enemyModel.Humanoid and enemyModel.Humanoid.Health > 0 and enemyModel:FindFirstChild("Head") then
                enemyData.Position = enemyModel.Head.Position
                enemyData.Distance = (playerPos - enemyData.Position).Magnitude
                if enemyData.Distance <= (range or Config.AttackRange) then
                    table.insert(livingEnemies, enemyData)
                end
            end
        end
        table.sort(livingEnemies, function(a, b) return a.Distance < b.Distance end)
        return livingEnemies
    end

    lastEnemyRefresh = currentTime
    local enemies = {}

    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("Head") then
            local isPlayer = false
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character == obj then isPlayer = true; break end
            end
            if not isPlayer and obj.Humanoid.Health > 0 then
                local headPos = obj.Head.Position
                local distance = (playerPos - headPos).Magnitude
                if distance <= (range or Config.AttackRange) then
                    table.insert(enemies, {
                        Model = obj,
                        Name = obj.Name,
                        Position = headPos,
                        Distance = distance,
                        Health = obj.Humanoid.Health,
                        MaxHealth = obj.Humanoid.MaxHealth
                    })
                end
            end
        end
    end
    
    table.sort(enemies, function(a, b) return a.Distance < b.Distance end)
    cachedEnemies = enemies
    return enemies
end

local function RefreshEnemiesList()
    lastEnemyRefresh = 0 
    return FindEnemiesInRange(500)
end

local function AutoAttackLogic()
    if isDungeonActive or not ValidatePlayerState() then return end
    local enemies = FindEnemiesInRange(Config.AttackRange)
    if #enemies > 0 then
        local nearestEnemy = enemies[1]
        local rootPart = GetCharacterRootPart()
        if rootPart then
            rootPart.CFrame = CFrame.new(nearestEnemy.Position + Vector3.new(0,2,0))
            local remote = GetAttackRemote()
            if remote then SafeFire(remote, "Attack", nearestEnemy.Model) end
        end
    end
end

local function FarmSelectedLogic()
    if isDungeonActive or not ValidatePlayerState() then return end
    if #selectedEnemyPositions == 0 then return end
    local rootPart = GetCharacterRootPart()
    if not rootPart then return end
    
    local playerPos = rootPart.Position
    local nearestPos, nearestDistance = nil, math.huge
    for _, pos in pairs(selectedEnemyPositions) do
        local distance = (playerPos - pos).Magnitude
        if distance < nearestDistance then nearestDistance = distance; nearestPos = pos end
    end
    
    if nearestPos then
        rootPart.CFrame = CFrame.new(nearestPos + Vector3.new(0,2,0))
        local remote = GetAttackRemote()
        if remote then SafeFire(remote, "AttackAtPosition", nearestPos) end
    end
end

local function FarmRandomLogic()
    if isDungeonActive or not ValidatePlayerState() then return end
    local enemies = FindEnemiesInRange(Config.AttackRange)
    if #enemies > 0 then
        local randomEnemy = enemies[math.random(1, #enemies)]
        local rootPart = GetCharacterRootPart()
        if rootPart then
            rootPart.CFrame = CFrame.new(randomEnemy.Position + Vector3.new(0,2,0))
            local remote = GetAttackRemote()
            if remote then SafeFire(remote, "Attack", randomEnemy.Model) end
        end
    end
end

local function AutoCollectLogic()
    if isDungeonActive or not ValidatePlayerState() then return end
    local rootPart = GetCharacterRootPart()
    if not rootPart then return end
    local remote = GetAttackRemote()
    if not remote then return end

    local collected = 0
    
    for _, obj in pairs(workspace:GetDescendants()) do
        if collected >= Config.MaxCollectPerFrame then break end
        
        if obj:IsA("Part") and (obj.Name:lower():find("drop") or obj.Name:lower():find("coin") or obj.Name:lower():find("reward")) then
            local distance = (rootPart.Position - obj.Position).Magnitude
            if distance < Config.CollectRange then
                SafeFire(remote, "Collect", obj)
                collected = collected + 1
            end
        end
    end
end

local function AutoRebirthLogic()
    if not ValidatePlayerState() then return end
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "RankUp")
        print("‚ö° ƒê√£ k√≠ch ho·∫°t Auto Rebirth/RankUp!")
    end
end

local function AutoOpenEggLogic()
    if not ValidatePlayerState() then return end
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Open Star", {[1] = "Egg"})
    end
end

local function StartGacha(gachaType)
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Crate Roll Start", {[1] = gachaType, [2] = true}) 
        task.wait(1)
        SafeFire(remote, "Crate Roll Stop") 
    end
end

local function DistributeStat(statName)
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Distribute Stat Point", {[1] = statName})
    end
end

local function TeleportToZone(zoneKey)
    local zoneName = Config.Zones[zoneKey]
    if not zoneName then return end

    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Zone Teleport", {[1] = zoneName}) 
        selectedZone = zoneKey 
        lastZone = zoneKey
        print("üöÄ ƒê√£ teleport ƒë·∫øn Zone: " .. zoneKey .. " (" .. zoneName .. ")")
    end
end

local function SafeTeleportToZone(zoneKey)
    if tick() - lastTeleportTime < Config.TeleportCooldown then
        print("‚è≥ ƒêang ch·ªù cooldown teleport...")
        return
    end
    
    TeleportToZone(zoneKey)
    lastTeleportTime = tick()
end

local function AutoJoinDungeonEasyLogic()
    if not ValidatePlayerState() then return end
    lastZone = selectedZone 
    local remote = GetReplyRemote()
    if remote then
        SafeFire(remote, "Join Gamemode", {[1] = Config.Zones["Dungeon Easy"]}) 
        print("üó∫Ô∏è ƒê√£ g·ª≠i y√™u c·∫ßu tham gia Dungeon Easy!")
    end
end

local function AutoFarmDungeonLogic()
    if not ValidatePlayerState() then 
        isPlayerInDungeon = false
        return
    end
    local rootPart = GetCharacterRootPart()
    if not rootPart then 
        isPlayerInDungeon = false
        return 
    end
    
    local enemies = FindEnemiesInRange(200)
    if #enemies > 0 then
        isPlayerInDungeon = true 
        local nearestEnemy = enemies[1]
        rootPart.CFrame = CFrame.new(nearestEnemy.Position + Vector3.new(0,5,0))
        
        local remote = GetAttackRemote()
        if remote then 
            SafeFire(remote, "Attack", nearestEnemy.Model) 
        end
    else
        isPlayerInDungeon = false
    end
end

local function DungeonExitCheck()
    if isDungeonActive and not isPlayerInDungeon and not activeLoops["AutoJoinDungeon"] and not activeLoops["AutoFarmDungeon"] then
        isDungeonActive = false
        autoDungeonFarmEnabled = false
        
        print("üö™ ƒê√£ tho√°t Dungeon. Quay v·ªÅ Zone c≈©: " .. lastZone)
        TeleportToZone(lastZone)
        RestoreFarmLoops()
        
        StopLoop("DungeonExitLoop")
        task.wait(2) 
        StartLoop("DungeonExitLoop", DungeonExitCheck, 5) 
    end
end

StartLoop("DungeonExitLoop", DungeonExitCheck, 5)

local function StartAutoRollLoop(gachaName)
    local loopName = "AutoRoll"..gachaName
    
    for name, _ in pairs(activeLoops) do
        if name:find("AutoRoll") then StopLoop(name) end
    end
    
    StartLoop(loopName, function() StartGacha(gachaName) end, 2)
end

-- ===================================================================
-- V. GUI FRAMEWORK (ƒê√É S·ª¨A L·ªñI PARENTING)
-- ===================================================================

local COLOR_PRIMARY = Color3.fromRGB(30, 30, 30)
local COLOR_SECONDARY = Color3.fromRGB(45, 45, 45)
local COLOR_ACCENT = Color3.fromRGB(220, 255, 40)
local COLOR_TEXT = Color3.fromRGB(255, 255, 255)
local COLOR_TEXT_DIM = Color3.fromRGB(180, 180, 180)
local COLOR_ON = Color3.fromRGB(0, 200, 0)
local COLOR_OFF = Color3.fromRGB(200, 0, 0)

local function CreatePanel(size, position, parent)
    local panel = Instance.new("Frame")
    panel.Size = size
    panel.Position = position
    panel.BackgroundColor3 = COLOR_PRIMARY
    panel.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = panel
    
    return panel
end

local function CreateLabel(text, size, position, parent, bold, fontSize, color)
    local label = Instance.new("TextLabel")
    label.Size = size
    label.Position = position
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = color or COLOR_TEXT
    label.Font = bold and Enum.Font.GothamBold or Enum.Font.Gotham
    label.TextSize = fontSize or 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = parent
    return label
end

-- Khai b√°o bi·∫øn TitleBar ·ªü ph·∫°m vi global tr∆∞·ªõc khi c√°c h√†m GUI ƒë∆∞·ª£c g·ªçi
local TitleBar 

function CreateToggleSwitch(text, description, default, callback, parent)  -- TH√äM PARAMETER PARENT
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 50)
    frame.BackgroundTransparency = 1
    frame.Parent = parent  -- S·ª¨A L·ªñI: TH√äM PARENT

    local label = CreateLabel(text, UDim2.new(0.6, 0, 0.5, 0), UDim2.new(0, 10, 0, 0), frame, true, 13)
    local desc = CreateLabel(description, UDim2.new(0.8, 0, 0.5, 0), UDim2.new(0, 10, 0.5, 0), frame, false, 11, COLOR_TEXT_DIM)

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, 65, 0, 28)
    toggleButton.Position = UDim2.new(1, -75, 0.5, -14)
    toggleButton.Text = default and "ON" or "OFF"
    toggleButton.TextColor3 = COLOR_PRIMARY
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 13
    toggleButton.BackgroundColor3 = default and COLOR_ACCENT or COLOR_SECONDARY
    toggleButton.Parent = frame

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = toggleButton
    
    local isOn = default

    toggleButton.MouseButton1Click:Connect(function()
        isOn = not isOn
        toggleButton.Text = isOn and "ON" or "OFF"
        toggleButton.BackgroundColor3 = isOn and COLOR_ACCENT or COLOR_SECONDARY
        toggleButton.TextColor3 = isOn and COLOR_PRIMARY or COLOR_ACCENT
        callback(isOn)
        if text:find("Stealth Mode") and TitleBar then
            stealthMode = isOn
            local indicator = TitleBar:FindFirstChild("StealthIndicator")
            local label = TitleBar:FindFirstChild("StealthLabel")
            if indicator and label then
                indicator.BackgroundColor3 = isOn and COLOR_ON or COLOR_OFF
                label.Text = isOn and "Stealth: ON" or "Stealth: OFF"
                label.TextColor3 = isOn and COLOR_ON or COLOR_OFF
            end
        end
    end)

    return frame
end

function CreateActionButton(text, description, callback, parent)  -- TH√äM PARAMETER PARENT
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 50)
    frame.BackgroundTransparency = 1
    frame.Parent = parent  -- S·ª¨A L·ªñI: TH√äM PARENT
    
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.4, 0, 0, 32)
    btn.Position = UDim2.new(0, 10, 0.5, -16)
    btn.BackgroundColor3 = COLOR_ACCENT
    btn.Text = text
    btn.TextColor3 = COLOR_PRIMARY
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 13
    btn.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = btn

    local desc = CreateLabel(description, UDim2.new(0.5, 0, 0.5, 0), UDim2.new(0.4, 20, 0.5, -10), frame, false, 11, COLOR_TEXT_DIM)
    desc.TextXAlignment = Enum.TextXAlignment.Left

    btn.MouseButton1Click:Connect(function()
        if callback then callback() end
    end)

    return frame
end

function CreateComboBox(text, description, items, callback, parent)  -- TH√äM PARAMETER PARENT
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 60)
    frame.BackgroundTransparency = 1
    frame.Parent = parent  -- S·ª¨A L·ªñI: TH√äM PARENT
    
    local label = CreateLabel(text, UDim2.new(0.5, 0, 0.5, 0), UDim2.new(0, 10, 0, 5), frame, true, 14)
    local desc = CreateLabel(description, UDim2.new(0.5, 0, 0.5, 0), UDim2.new(0, 10, 0.5, 0), frame, false, 11, COLOR_TEXT_DIM)

    local dropdown = Instance.new("TextButton")
    dropdown.Size = UDim2.new(0.4, 0, 0, 32)
    dropdown.Position = UDim2.new(0.55, 0, 0.25, 0)
    dropdown.BackgroundColor3 = COLOR_SECONDARY
    dropdown.Text = items[1] or "Select"
    dropdown.TextColor3 = COLOR_ACCENT
    dropdown.Font = Enum.Font.GothamBold
    dropdown.TextSize = 13
    dropdown.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = dropdown

    local selected = items[1]
    local menuOpen = false
    local menu = nil
    
    dropdown.MouseButton1Click:Connect(function()
        if menuOpen and menu then menu:Destroy(); menu = nil; menuOpen = false; return end

        menu = Instance.new("ScrollingFrame")
        menu.Size = UDim2.new(0.4, 0, 0, math.min(#items * 28, 200)) 
        menu.Position = UDim2.new(0.55, 0, 0.75, 0)
        menu.BackgroundColor3 = COLOR_SECONDARY
        menu.Parent = frame
        menu.ZIndex = 5 
        menu.ScrollBarThickness = 5
        menu.ScrollBarImageColor3 = COLOR_ACCENT
        menu.CanvasSize = UDim2.new(0, 0, 0, #items * 28)

        local listLayout = Instance.new("UIListLayout")
        listLayout.Padding = UDim.new(0, 2)
        listLayout.Parent = menu

        local menuCorner = Instance.new("UICorner")
        menuCorner.CornerRadius = UDim.new(0, 6)
        menuCorner.Parent = menu

        for i, item in ipairs(items) do
            local itemBtn = Instance.new("TextButton")
            itemBtn.Size = UDim2.new(1, 0, 0, 28)
            itemBtn.BackgroundColor3 = (item == selected) and COLOR_PRIMARY or COLOR_SECONDARY
            itemBtn.Text = item
            itemBtn.TextColor3 = (item == selected) and COLOR_ACCENT or COLOR_TEXT
            itemBtn.Font = Enum.Font.Gotham
            itemBtn.TextSize = 12
            itemBtn.Parent = menu
            
            itemBtn.MouseButton1Click:Connect(function()
                dropdown.Text = item
                selected = item
                menu:Destroy()
                menu = nil
                menuOpen = false
                if callback then callback(item) end
            end)
        end
        menuOpen = true
    end)

    return frame
end

-- ===================================================================
-- VI. GUI CONSTRUCTION (ƒê√É S·ª¨A T·∫§T C·∫¢ L·ªñI PARENTING)
-- ===================================================================

local HimonoHub = Instance.new("ScreenGui")
HimonoHub.Name = "HimonoHubSulfur"
HimonoHub.ResetOnSpawn = false
HimonoHub.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
HimonoHub.Parent = game.CoreGui

local MainContainer = CreatePanel(UDim2.new(0, 500, 0, 480), UDim2.new(0.5, -250, 0.5, -240), HimonoHub)
MainContainer.BackgroundColor3 = COLOR_PRIMARY

-- Kh·ªüi t·∫°o TitleBar (l∆∞u tr·ªØ trong bi·∫øn global TitleBar)
TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 40)
TitleBar.BackgroundColor3 = COLOR_PRIMARY
TitleBar.Parent = MainContainer

local Title = CreateLabel("üëë HIMONO HUB v4.5 - MAX SPEED & STABLE", UDim2.new(1, -100, 1, 0), UDim2.new(0, 15, 0, 0), TitleBar, true, 16, COLOR_ACCENT)
Title.TextXAlignment = Enum.TextXAlignment.Left

local StealthIndicator = Instance.new("Frame")
StealthIndicator.Name = "StealthIndicator"
StealthIndicator.Size = UDim2.new(0, 10, 0, 10)
StealthIndicator.Position = UDim2.new(1, -70, 0.5, -5)
StealthIndicator.BackgroundColor3 = stealthMode and COLOR_ON or COLOR_OFF
StealthIndicator.Parent = TitleBar

local StealthCorner = Instance.new("UICorner")
StealthCorner.CornerRadius = UDim.new(1, 0)
StealthCorner.Parent = StealthIndicator

local StealthLabel = CreateLabel(stealthMode and "Stealth: ON" or "Stealth: OFF", UDim2.new(0, 60, 1, 0), UDim2.new(1, -60, 0, 0), TitleBar, false, 11, stealthMode and COLOR_ON or COLOR_OFF)
StealthLabel.Name = "StealthLabel"
StealthLabel.TextXAlignment = Enum.TextXAlignment.Right

local TabContainer = CreatePanel(UDim2.new(0, 150, 1, -50), UDim2.new(0, 10, 0, 45), MainContainer)
TabContainer.BackgroundColor3 = COLOR_PRIMARY

local TabListLayout = Instance.new("UIListLayout")
TabListLayout.FillDirection = Enum.FillDirection.Vertical
TabListLayout.Padding = UDim.new(0, 5)
TabListLayout.Parent = TabContainer

local ContentScroll = Instance.new("ScrollingFrame")
ContentScroll.Size = UDim2.new(1, -170, 1, -50)
ContentScroll.Position = UDim2.new(0, 160, 0, 45)
ContentScroll.BackgroundColor3 = COLOR_SECONDARY
ContentScroll.BorderSizePixel = 0
ContentScroll.ScrollBarThickness = 5
ContentScroll.ScrollBarImageColor3 = COLOR_ACCENT
ContentScroll.CanvasSize = UDim2.new(0, 0, 2, 0)
ContentScroll.Parent = MainContainer

local ContentCorner = Instance.new("UICorner")
ContentCorner.CornerRadius = UDim.new(0, 8)
ContentCorner.Parent = ContentScroll

local ContentLayout = Instance.new("UIListLayout")
ContentLayout.Padding = UDim.new(0, 10)
ContentLayout.Parent = ContentScroll

local tabs = {
    "üè† MAIN", "üåæ FARM", "üó∫Ô∏è DUNGEON", "üé∞ GACHA", 
    "‚ö° STATS", "üöÄ TELEPORT", "ü•ö EGG", "‚öôÔ∏è SETTINGS", "üéØ ENEMIES"
}
local tabFrames, tabButtons = {}, {}

for i, tabName in ipairs(tabs) do
    local tabButton = Instance.new("TextButton")
    tabButton.Size = UDim2.new(1, -10, 0, 35)
    tabButton.BackgroundColor3 = i == 1 and COLOR_ACCENT or COLOR_PRIMARY
    tabButton.Text = tabName
    tabButton.TextColor3 = i == 1 and COLOR_PRIMARY or COLOR_TEXT
    tabButton.Font = Enum.Font.GothamBold
    tabButton.TextSize = 13
    tabButton.Parent = TabContainer
    tabButton.LayoutOrder = i

    local tabButtonCorner = Instance.new("UICorner")
    tabButtonCorner.CornerRadius = UDim.new(0, 6)
    tabButtonCorner.Parent = tabButton

    local contentFrame = Instance.new("Frame")
    contentFrame.Size = UDim2.new(1, 0, 1, 0)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Visible = i == 1
    contentFrame.Parent = ContentScroll

    local contentLayout = Instance.new("UIListLayout")
    contentLayout.Padding = UDim.new(0, 10)
    contentLayout.Parent = contentFrame

    tabFrames[tabName] = contentFrame
    tabButtons[tabName] = tabButton

    tabButton.MouseButton1Click:Connect(function()
        for name, frame in pairs(tabFrames) do
            frame.Visible = (name == tabName)
        end
        for name, btn in pairs(tabButtons) do
            btn.BackgroundColor3 = (name == tabName) and COLOR_ACCENT or COLOR_PRIMARY
            btn.TextColor3 = (name == tabName) and COLOR_PRIMARY or COLOR_TEXT
        end
    end)
end

-- ===================================================================
-- VII. TAB DEFINITIONS (ƒê√É S·ª¨A T·∫§T C·∫¢ L·ªñI PARENTING)
-- ===================================================================

local mainContent = tabFrames["üè† MAIN"]
CreateLabel("CORE AUTOMATION:", UDim2.new(1, 0, 0, 20), UDim2.new(0, 10, 0, 5), mainContent, true, 16, COLOR_ACCENT)

local autoAttackToggle = CreateToggleSwitch(
    "Auto Attack (Nearest)", "T·ª± ƒë·ªông t·∫•n c√¥ng k·∫ª ƒë·ªãch g·∫ßn nh·∫•t (Speed: " .. Config.FarmInterval .. "s)", false, 
    function(enabled)
        if enabled then StartLoop("AutoAttack", AutoAttackLogic, Config.FarmInterval) else StopLoop("AutoAttack") end
    end,
    mainContent  -- TH√äM PARENT
)

local autoDropsToggle = CreateToggleSwitch(
    "Auto Collect All Drops", "T·ª± ƒë·ªông nh·∫∑t v·∫≠t ph·∫©m quanh b·∫°n (Range: " .. Config.CollectRange .. ")", false, 
    function(enabled)
        if enabled then StartLoop("AutoCollect", AutoCollectLogic, 1.0) else StopLoop("AutoCollect") end
    end,
    mainContent  -- TH√äM PARENT
)

local autoRebirthToggle = CreateToggleSwitch(
    "Auto Rebirth / RankUp", "T·ª± ƒë·ªông RankUp/Rebirth khi c√≥ th·ªÉ (Check: " .. Config.RebirthCheckInterval .. "s)", false, 
    function(enabled)
        if enabled then StartLoop("AutoRebirth", AutoRebirthLogic, Config.RebirthCheckInterval)
        else StopLoop("AutoRebirth") end
    end,
    mainContent  -- TH√äM PARENT
)

local farmContent = tabFrames["üåæ FARM"]
CreateLabel("FARMING METHODS (Speed: " .. Config.FarmInterval .. "s):", UDim2.new(1, 0, 0, 20), UDim2.new(0, 10, 0, 5), farmContent, true, 16, COLOR_ACCENT)

local autoFarmSelectedToggle = CreateToggleSwitch(
    "Auto Farm Selected Positions", "Farm t·∫°i c√°c v·ªã tr√≠ ƒë√£ ƒë√°nh d·∫•u trong tab ENEMIES", false, 
    function(enabled)
        if enabled then StartLoop("FarmSelected", FarmSelectedLogic, Config.FarmInterval) else StopLoop("FarmSelected") end
    end,
    farmContent  -- TH√äM PARENT
)

local autoFarmRandomToggle = CreateToggleSwitch(
    "Farm Random Enemies", "T·ª± ƒë·ªông farm ng·∫´u nhi√™n k·∫ª ƒë·ªãch trong ph·∫°m vi", false, 
    function(enabled)
        if enabled then StartLoop("FarmRandom", FarmRandomLogic, Config.FarmInterval) else StopLoop("FarmRandom") end
    end,
    farmContent  -- TH√äM PARENT
)

local dungeonContent = tabFrames["üó∫Ô∏è DUNGEON"]
CreateLabel("DUNGEON AUTOMATION:", UDim2.new(1, 0, 0, 20), UDim2.new(0, 10, 0, 5), dungeonContent, true, 16, COLOR_ACCENT)

local autoJoinDungeonToggle = CreateToggleSwitch(
    "Auto Join Dungeon Easy", "T·ª± ƒë·ªông g·ª≠i y√™u c·∫ßu v√†o Dungeon Easy (Check: " .. Config.DungeonJoinInterval .. "s)", false, 
    function(enabled)
        if enabled then 
            isDungeonActive = true
            SaveAndStopFarmLoops()
            StartLoop("AutoJoinDungeon", AutoJoinDungeonEasyLogic, Config.DungeonJoinInterval)
        else 
            StopLoop("AutoJoinDungeon")
            isDungeonActive = activeLoops["AutoFarmDungeon"] or false
            if not isDungeonActive then RestoreFarmLoops() end
        end
    end,
    dungeonContent  -- TH√äM PARENT
)

local autoFarmDungeonToggle = CreateToggleSwitch(
    "Auto Farm Dungeon (Max Speed)", "T·ª± ƒë·ªông Teleport v√† farm qu√°i trong Dungeon (Speed: " .. Config.FarmInterval .. "s)", false, 
    function(enabled)
        autoDungeonFarmEnabled = enabled
        if enabled then 
            isDungeonActive = true
            SaveAndStopFarmLoops()
            StartLoop("AutoFarmDungeon", AutoFarmDungeonLogic, Config.FarmInterval)
        else 
            StopLoop("AutoFarmDungeon")
            isDungeonActive = activeLoops["AutoJoinDungeon"] or false
            if not isDungeonActive then RestoreFarmLoops() end
        end
    end,
    dungeonContent  -- TH√äM PARENT
)

local leaveDungeonBtn = CreateActionButton("Force Leave Dungeon", "Tho√°t Dungeon v√† quay v·ªÅ Zone c≈©", function()
    isDungeonActive = true; isPlayerInDungeon = false;
    StopLoop("AutoJoinDungeon"); StopLoop("AutoFarmDungeon");
    StopLoop("DungeonExitLoop")
    DungeonExitCheck()
end,
dungeonContent  -- TH√äM PARENT
)

-- ... (C√ÅC TAB KH√ÅC C≈®NG TH√äM PARENT T∆Ø∆†NG T·ª∞)

EnableAntiAFK()

print("üëë Himono Hub v4.5 - MAX SPEED & STABLE LOADED! (FULLY FIXED)")
